//version 1.0 - 26. February 2023 - Leif Dehmelt - https://ccb.tu-dortmund.de/professuren/cb/dehmelt/

//
//
//
//settings for choosing anlysis type
//
//
//

analyze_protrusion_profile=true;
analyze_retraction_profile=true;
analyze_protrusion_retraction_dynamics=true;
analyze_velocity_crosscorrelation=true;
analysis_summary=true;



//
//
//
//settings for file handling
//
//
//


//base directory of data
base_path="/Users/leifdehmelt/Documents/papers/rho_network_paper/Suchet_revision/final/analysis_code/protrusion_retraction_signal_enrichment/example_rac_activity_data/";

//mask
mask_path="stable_TYFPQ-BG";

//ignal
signal1_path="stable_TRFPQ-BG";


//number of files to analyze
numPaths=1;

//index of first file to analyze
firstPath=0;

//list of cells to be analyzed
paths=newArray(80);

paths[0]="-1";
paths[1]="-2";



//list of threshold methods to use
th_method=newArray(80);

th_method[0]="Default";
th_method[1]="Default";



//
//
//
//settings for enrichment analysis
//
//
//

//velocity threshold for protrusions/retractions
theshold=0.1;

//smaller objects will be removed for average intensity measurement
filter_small_objects=100;

//only consider meassurements that contain at least this number of pixels in the velocity map for the selected velocity threshold
pixel_count_threshold=20;



//number of time shifts to analyze and how many frames each timeshift should be apart from the next.  
num_taus = 50;
tau_shift = 1;


//spatial scale for dynamics analysis of protrusion retraction
//lower values will speed up analysis at the cost of spatial accuracy
//this is the numberw of spatial bins to consider around the cell circumference
spatial_scale_dynamics = 100;



//
//
//
// begin of code - do not edit
//
//
//

close("*");

//helper function to analyze the directory structure generated by the adapt script
//will exit with an error, if no cells or multiple cells are detected

function findMapDirectory(base_directory,signal_directory) {
	base_directory=base_directory+"/Adapt_v3.0.1/";
	print(base_directory);
	adapt_directory=getFileList(base_directory);
	if(adapt_directory.length == 0)
	{
		exit("Error: directory does not exist: "+ base_directory);
	}
	if(!File.exists(base_directory+signal_directory))
	{
		exit("Error: directory does not exist: "+ base_directory+signal_directory);
	}
	base_directory=base_directory+signal_directory+"/Individual_Cell_Data_Output/";
	cell_directory=getFileList(base_directory);
	if(cell_directory.length>1)
	{
		exit("Error: multiple cells in directory: "+ base_directory);
	}
	base_directory=base_directory+cell_directory[0];
	return base_directory;
}

//check all directories for the whole analysis to avoid program exit midway though analysis
for(j=firstPath;j<(firstPath+numPaths);j++)
{
	if(analyze_protrusion_profile ||
			analyze_retraction_profile ||
			analyze_velocity_crosscorrelation)
	{
		if(!File.exists(base_path+mask_path+"/"+mask_path+paths[j]+".tif"))
		{
			exit("Error: file does not exist: "+ base_path+mask_path+"/"+mask_path+paths[j]);
		}
		if(!File.exists(base_path+signal1_path+"/"+signal1_path+paths[j]+".tif"))
		{
			exit("Error: file does not exist: "+ base_path+signal1_path+"/"+signal1_path+paths[j]);
		}
		result_directory1=findMapDirectory(base_path,signal1_path+paths[j]+"_Output");
	}
	else
	{
		result_directory1=findMapDirectory(base_path,signal1_path+paths[j]+"_Output");
	}
}

//cycle through all paths that contain data for individual cells, each.
for(j=firstPath;j<(firstPath+numPaths);j++)
{
getDateAndTime(year, month, dayOfWeek, dayOfMonth, hour, minute, second, msec);
time_str=""+year+"_"+month+"_"+dayOfMonth+"_"+hour+"_"+minute;
print(time_str);
analysis_log = File.open(base_path+signal1_path+"/"+time_str+"_"+signal1_path+paths[j]+"_tif"+"_analysis_log.txt");

print(analysis_log,"-----------------------------------");
print(analysis_log,"parameters");
print(analysis_log,"-----------------------------------");
print(analysis_log,"");
print(analysis_log,"base_path: "+base_path);
print(analysis_log,"signal1_path: "+signal1_path);
print(analysis_log,"num_taus: "+num_taus);
print(analysis_log,"tau_shift: "+tau_shift);
print(analysis_log,"pixel_count_threshold: "+pixel_count_threshold);
print(analysis_log,"theshold: "+theshold);
print(analysis_log,"filter_small_objects: "+filter_small_objects);
print(analysis_log,"threshold method: "+th_method[j]);
print(analysis_log,"");
print(analysis_log,"");

//select the analysis type for the current data set
for(select_mode=0;select_mode<4;select_mode++)
{

run("Clear Results");


do_analysis=false;

if(select_mode==0)
{
	mode="protrusion_profile";
	if(analyze_protrusion_profile)
	{
		do_analysis=true;
	}
}
if(select_mode==1)
{
	mode="retraction_profile";
		if(analyze_retraction_profile)
	{
		do_analysis=true;
	}
}
if(select_mode==2)
{
	mode="velocity_crosscorrelation";
		if(analyze_velocity_crosscorrelation)
	{
		do_analysis=true;
	}
}
if(select_mode==3)
{
	mode="protrusion_retraction_dynamics";
	if(analyze_protrusion_retraction_dynamics)
	{
		do_analysis=true;
	}
}


print(mode);

if(do_analysis)
{
	print("do analysis");
	print(analysis_log,"-----------------------------------");
	print(analysis_log,"Mode: "+mode);
	print(analysis_log,"-----------------------------------");
	print(analysis_log,"");
	print(analysis_log,"");
	
//perform the analysis for the selected analysis type

//extract velocity signal crosscorrelation analysis data from the VelMap_SigMap_CrossCorrelation.tif file generated by the ADAPT analysis
if(mode=="velocity_crosscorrelation")
{
	print(analysis_log,"Using plot profile of lines 49 and 50 in VelMap_SigMap_CrossCorrelation.tif");
	
	result_directory=findMapDirectory(base_path,signal1_path+paths[j]+"_Output");

	open(result_directory+"/VelMap_SigMap_CrossCorrelation.tif");
	rename("CC.tif");
	run("Line Width...", "line=1");
	makeLine(0, 49, 100, 49);
	run("Plot Profile");
	Plot.getValues(xpoints1, ypoints1);
	selectWindow("CC.tif");
	makeLine(0, 50, 100, 50,1);
	run("Plot Profile");
	Plot.getValues(xpoints2, ypoints2);
	tau=-49.5;
	for(tau_counter=0;tau_counter<xpoints1.length;tau_counter++)
	{
		average_cc=(ypoints1[tau_counter]+ypoints2[tau_counter])/2.0;
		setResult("tau",tau_counter,tau);
		setResult("crosscorrelation",tau_counter,average_cc);
		tau++;
	}	
}
//perform protrusion or retraction signal enrichment analysis
else if(mode=="protrusion_profile" || mode=="retraction_profile")
{

if(mode=="protrusion_profile")
{
	lower_th=theshold;
	higher_th=10000;
}
if(mode=="retraction_profile")
{
	lower_th=-10000;
	higher_th=-theshold;
}

//open files

print("opening: "+base_path+mask_path+"/"+mask_path+paths[j]+".tif");
open(base_path+mask_path+"/"+mask_path+paths[j]+".tif");
rename("Mask.tif");
open(base_path+signal1_path+"/"+signal1_path+paths[j]+".tif");
rename("Signal");

result_directory=findMapDirectory(base_path,signal1_path+paths[j]+"_Output");

open(result_directory+"/VelocityMap.tif");
open(result_directory+"/SignalMap.tif");

//analyze average signal in whole cell attachement area

roiManager("reset");

selectWindow("Mask.tif");

run("Make Binary", "method="+th_method[j]+" background=Dark calculate");
run("Fill Holes", "stack");
run("Analyze Particles...", "size="+filter_small_objects+"-Infinity show=Masks stack");
selectWindow("Mask of Mask.tif");

for(i=1;i<=nSlices;i++)
{
	setSlice(i);
	run("Select None");
	run("Create Selection");
	roiManager("Add");
}

selectWindow("Signal");

average_signal=0;
average_signal_count=0;

for(i=1;i<=nSlices;i++)
{
	roiManager("Select", i-1);
	getStatistics(area, mean, min, max, std, histogram);
	average_signal=average_signal+mean;
	average_signal_count++;
}

average_signal=average_signal/average_signal_count;

//save a record for the cell traces generated by the analysis of the average signal in whole cell attachement area

run("Enhance Contrast", "saturated=0.35");
run("RGB Color");
setForegroundColor(255, 255, 0);

for(i=1;i<=nSlices;i++)
{
	roiManager("Select", i-1);
	run("Draw", "slice");
}

run("Select None");
save(base_path+mask_path+"/"+mask_path+paths[j]+"_border_for_"+mode+".tif");

print(analysis_log,"average_signal: "+average_signal);

roiManager("reset");

//analyze the average signal in protrusions and retractions.

//perform the analysis for different time shifts (tau)
tau_counter=0;
for(x=-num_taus;x<num_taus;x=x+tau_shift)
{
	//open velocity map and time shift by tau.
	selectWindow("VelocityMap.tif");
	run("Duplicate...", "title=shifted_velocity");
	run("Translate...", "x="+x+" y=0 interpolation=None");
		
		//Identify protrusions of retractions based on thresholding of the time-shifted velocity map. Create selections for further analysis.
		setThreshold(lower_th, higher_th);
		run("Create Selection");
		if(getValue("selection.size")>pixel_count_threshold)
			{
				roiManager("Add");
				has_selection_single=1;
			}
			else {
				has_selection_single=0;
			}
		//use previously saved selections to analyze the signal map.
		selectWindow("SignalMap.tif");
		if(has_selection_single==1)
			{
				roiManager("Select", 0);
				getStatistics(area, mean, min, max, std, histogram);
			}
			else 
			{
				area=NaN;
				mean=NaN;
				min=NaN;
				max=NaN;
				std=NaN;
			}
			if(j==firstPath)
			{
				setResult("tau",tau_counter,x);
			}
			
			if(mode=="retraction_profile")
			{
				setResult("retraction",tau_counter,(100*mean/average_signal)-100);
			}
			if(mode=="protrusion_profile")
			{
				setResult("protrusion",tau_counter,(100*mean/average_signal)-100);
			}
	roiManager("reset");
	tau_counter++;
	selectWindow("shifted_velocity");
	close();
}
selectWindow("Mask.tif");
close();
selectWindow("Signal");
close();
selectWindow("SignalMap.tif");
close();
selectWindow("VelocityMap.tif");
close();

//save the results from the protrusion retraction signal enrichment analysis 

if(mode=="protrusion_profile")
{
	Table.save(base_path+signal1_path+"/"+signal1_path+paths[j]+"_"+"protrusion_profile.xls");
	close("*");
	run("Clear Results");
}
if(mode=="retraction_profile")
{
	Table.save(base_path+signal1_path+"/"+signal1_path+paths[j]+"_"+"retraction_profile.xls");
	close("*");
	run("Clear Results");
}

}
//perform protrusion retraction dynamics analysis 
else if(mode=="protrusion_retraction_dynamics")
{
	//open the velocity map
	result_directory=findMapDirectory(base_path,signal1_path+paths[j]+"_Output");
	open(result_directory+"/VelocityMap.tif");

	//initialize the analsis
	width=getWidth();

	run("Size...", "width="+width+" height="+spatial_scale_dynamics+" depth=1 average interpolation=Bilinear");

	height=getHeight();
	
	//protrusion_retraction_cycle:
	//from start of protrusion to start of retraction
	
	protrusion_retraction_cycle_count=0;
	average_protrusion_retraction_cycle=0;
	duration_protrusion_retraction_cycle=0;
	protrusion_retraction_cycle_stage=0;

	for(y=0;y<height;y=y+1)
	{
		//reset values for line-wise calculation of stdev
		protrusion=false;
		retraction=false;
		//ignore the first state - start analysis after first transition between protrusion, pause or retraction ocurred
		ignore=true;
		duration=0;

		duration_protrusion_retraction_cycle=0;
		protrusion_retraction_cycle_stage=0;
	
		val=getPixel(0,y);
		if(val>theshold)
		{
			protrusion=true;
		}
		if(val<-theshold)
		{
			retraction=true;
		}
		
		for(x=0;x<width;x=x+1)
		{
			val=getPixel(x,y);			
			
			//in a protrusion
			if(ignore==false && protrusion==true)
			{
				if(val>theshold)
				{
					duration++;
				}
				//transition protrusion to pause
				else 
				{
					//continue pr cycle
					if(protrusion_retraction_cycle_stage==1)
					{
						duration_protrusion_retraction_cycle=duration_protrusion_retraction_cycle+duration;
						protrusion_retraction_cycle_stage=1;
					}					
					duration=0;
					protrusion=false;
				}
			}
			//in a retraction
			else if(ignore==false && retraction==true)
			{
				//transition retraction to pause or protrusion
				if(val>=-theshold)
				{
					retraction=false; 
				}
			}
			//in a pause
			else if(ignore==false && retraction==false && protrusion==false)
			{
				if(!(val>-theshold && val<theshold))
				{
					//transition pause to retraction
					if(val<-theshold)
					{
						retraction=true;
						//end of pr cycle
						if(protrusion_retraction_cycle_stage==1)
						{
							duration_protrusion_retraction_cycle=duration_protrusion_retraction_cycle+duration;
							average_protrusion_retraction_cycle=average_protrusion_retraction_cycle+duration_protrusion_retraction_cycle;
							protrusion_retraction_cycle_count++;
							protrusion_retraction_cycle_stage=0;
							duration_protrusion_retraction_cycle=0;
						}
					}
					//transition pause to protrusion
					if(val>theshold)
					{
						protrusion=true;
						
						//continue pr cycle
						if(protrusion_retraction_cycle_stage==1)
						{
							duration_protrusion_retraction_cycle=duration_protrusion_retraction_cycle+duration;
							protrusion_retraction_cycle_stage=1;
						}
						//start pr cycle
						if(protrusion_retraction_cycle_stage==0)
						{
							protrusion_retraction_cycle_stage=1;
						}
					}
					duration=0;
				}
				else {
					duration++;
				}
			}
			//ignore the first state - start analysis after first transition between protrusion, pause or retraction ocurred
			//first search for the first transition
			if(ignore==true)
			{
				
				if(protrusion==true && val<theshold)
				{
					ignore=false;
					protrusion==false;
				}
				if(retraction==true && val>-theshold)
				{
					ignore=false;
					retraction==false;
				}
				if((protrusion==false && retraction==false) && (val<-theshold || val>theshold))
				{
					ignore=false;
					//start pr cycle
					if(val>theshold)
					{
						protrusion=true;
						protrusion_retraction_cycle_stage=1;
						duration_protrusion_retraction_cycle=0;
					}
				}
			}
			
		}
	}
	//calculate average and set results
	

	average_protrusion_retraction_cycle=average_protrusion_retraction_cycle/protrusion_retraction_cycle_count;

	setResult("average_protrusion_retraction_cycle",0,average_protrusion_retraction_cycle);
	setResult("protrusion_retraction_cycle_count",0,protrusion_retraction_cycle_count/height);

}
//save results
if(mode=="protrusion_retraction_dynamics")
{
	Table.save(base_path+signal1_path+"/"+signal1_path+paths[j]+"_"+"protrusion_retraction_dynamics.xls");
	close("*");
	run("Clear Results");
}
if(mode=="velocity_crosscorrelation")
{
	Table.save(base_path+signal1_path+"/"+signal1_path+paths[j]+"_"+"velocity_crosscorrelation.xls");
	close("*");
	run("Clear Results");
}
}

}
	File.close(analysis_log); 
}

//generate and save an analysis summary

if(analysis_summary)
{
	analysis_log = File.open(base_path+"/"+time_str+"_"+signal1_path+"_analysis_summary_log.txt");
	print(analysis_log,"-----------------------------------");
	print(analysis_log,"Mode: Analysis Summary");
	print(analysis_log,"-----------------------------------");
	print(analysis_log,"");
	print(analysis_log,"");
	print(analysis_log,"Analysis data was combined on: "+time_str);

protrusion_summary_exists=false;
retraction_summary_exists=false;
velocity_cc_summary_exists=false;
protrusion_retraction_dynamics_summary_exists=false;

//cycle through all paths to generate summary

for(j=firstPath;j<(firstPath+numPaths);j++)
{
	//summary for protrusion profiles (if they exist)
	result_directory=base_path+signal1_path+"/";
	temp_filename=signal1_path+paths[j]+"_"+"protrusion_profile.xls";
	if(File.exists(result_directory+temp_filename))
	{
		Table.open(result_directory+temp_filename);
		if(j==firstPath)
		{
			protrusion_summary_exists=true;
			Table.create("protrusion_summary");
			selectWindow(temp_filename);
			colx=Table.getColumn("tau"); 
			selectWindow("protrusion_summary");
			Table.setColumn("tau", colx);
			Table.set(base_path, 0,0);
			
		}
		selectWindow(temp_filename);
		col=Table.getColumn("protrusion"); 
		close(temp_filename);
		selectWindow("protrusion_summary");
		Table.setColumn(paths[j], col);
	}
	//summary for retraction profiles (if they exist)
	result_directory=base_path+signal1_path+"/";
	temp_filename=signal1_path+paths[j]+"_"+"retraction_profile.xls";
	if(File.exists(result_directory+temp_filename))
	{
		Table.open(result_directory+temp_filename);
		if(j==firstPath)
		{
			retraction_summary_exists=true;
			Table.create("retraction_summary");
			selectWindow(temp_filename);
			colx=Table.getColumn("tau"); 
			selectWindow("retraction_summary");
			Table.setColumn("tau", colx);
			Table.set(base_path, 0,0);
		}
		selectWindow(temp_filename);
		col=Table.getColumn("retraction"); 
		close(temp_filename);
		selectWindow("retraction_summary");
		Table.setColumn(paths[j], col);
	}
	//summary for velocity crosscorrelation (if it exist)
	result_directory=base_path+signal1_path+"/";
	temp_filename=signal1_path+paths[j]+"_"+"velocity_crosscorrelation.xls";
	if(File.exists(result_directory+temp_filename))
	{
		Table.open(result_directory+temp_filename);
		if(j==firstPath)
		{
			velocity_cc_summary_exists=true;
			Table.create("velocity_crosscorrelation_summary");
			selectWindow(temp_filename);
			colx=Table.getColumn("tau"); 
			selectWindow("velocity_crosscorrelation_summary");
			Table.setColumn("tau", colx);
			Table.set(base_path, 0,0);
		}
		selectWindow(temp_filename);
		col=Table.getColumn("crosscorrelation"); 
		close(temp_filename);
		selectWindow("velocity_crosscorrelation_summary");
		Table.setColumn(paths[j], col);
	}
	//summary for protrusion retraction dynamics analysis (if it exist)
	result_directory=base_path+signal1_path+"/";
	temp_filename=signal1_path+paths[j]+"_"+"protrusion_retraction_dynamics.xls";
	if(File.exists(result_directory+temp_filename))
	{
		Table.open(result_directory+temp_filename);
		if(j==firstPath)
		{
			protrusion_retraction_dynamics_summary_exists=true;
			Table.create("protrusion_retraction_dynamics_summary");
			Table.set(base_path, 0,0);
		}
		selectWindow(temp_filename);
		col1=Table.get("average_protrusion_retraction_cycle",0); 
		col2=Table.get("protrusion_retraction_cycle_count",0); 
		close(temp_filename);
		selectWindow("protrusion_retraction_dynamics_summary");
		Table.set("average_protrusion_retraction_cycle", j, col1);
		Table.set("protrusion_retraction_cycle_count", j, col2);
	}
}
//save results
if(protrusion_summary_exists)
{
selectWindow("protrusion_summary");
Table.save(base_path+signal1_path+"_protrusion_summary.xls");
close("protrusion_summary");
}

if(retraction_summary_exists)
{
selectWindow("retraction_summary");
Table.save(base_path+signal1_path+"_retraction_summary.xls");
close("retraction_summary");
}

if(velocity_cc_summary_exists)
{
selectWindow("velocity_crosscorrelation_summary");
Table.save(base_path+signal1_path+"_velocity_crosscorrelation_summary.xls");
close("velocity_crosscorrelation_summary");
}

if(protrusion_retraction_dynamics_summary_exists)
{
selectWindow("protrusion_retraction_dynamics_summary");
Table.save(base_path+signal1_path+"_protrusion_retraction_dynamics_summary.xls");
close("protrusion_retraction_dynamics_summary");
}

run("Clear Results");
}